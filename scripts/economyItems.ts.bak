import { readdirSync, writeFileSync } from 'fs'

type If<T extends boolean,
	IfTrue,
	IfFalse = null
> = T extends true ? IfTrue : IfFalse

const sources = ['src', 'typings'] as const
const types = ['json', 'mongodb'] as const

const baseDirectories: ISourceFolder<false, false> = {
	classes: {
		guild: [],
		user: [],
		util: [],
		root: []
	},

	managers: []
}

const fileTexts = {
	json: {
		js: '',
		ts: ''
	},

	mongodb: {
		js: '',
		ts: ''
	}
}


const getFiles = (path: string): string[] => {
	const files = readdirSync(path)
		.filter(fileName => fileName.includes('.'))
		.sort()

	return files
}

const createJSDeclaration = (fileName: string, path: string) => {
	const fileNameReplaced = fileName.replace('.js', '')

	return `  ${fileNameReplaced}: require('${path.replace('mongodb/', '')}/${fileNameReplaced}')`
}

const createTSDeclaration = (fileName: string, path: string, options?: {
	multipleImports?: string[]
}) => {
	const fileNameReplaced = fileName.replace('.d.ts', '')

	if(options?.multipleImports?.length) {
		return `export { ${options?.multipleImports.join(', ')} } from '${path.replace('mongodb/', '')}/${fileNameReplaced}'`
	} else {
		return `export import ${fileNameReplaced} = require('${path.replace('mongodb/', '')}/${fileNameReplaced}')`
	}
}

const defineMultipleImports = (fileName: string, extension = '.d.ts'): string[] => {
	const fileNameReplaced = fileName.replace(extension, '')

	switch (fileNameReplaced) {
		case 'CurrencyObject': {
			return ['CurrencyObject', 'CurrencyPropertyType']
		}

		case 'ItemProperties': {
			return ['ItemProperties', 'ItemPropertyType']
		}

		case 'RewardTypes': {
			return ['Reward', 'RewardType']
		}

		case 'CachedItems': {
			return [
				'CachedBalance', 'CachedBank', 
				'CachedCooldowns', 'CachedCurrency', 
				'CachedGuilds', 'CachedHistory', 
				'CachedInventory', 'CachedShop', 'CachedUsers'
			]
		}
		
		default: {
			return []
		}
	}
}

const generateUserMessage = (type: typeof types[number], source: typeof sources[number]): string => {
	if (source == 'src') {
		const message = 
`// This file contains all the managers and classes Economy has (e.g. EconomyItems)
// This file was generated automatically and not recommended to edit it yourself.
		
// Any of these items can be imported using:
// const { something } = require('discord-economy-super${type == 'mongodb' ? '/mongodb' : ''}')

// or in TypeScript (all the economy types and interfaces available) 
// import { something } = from 'discord-economy-super${type == 'mongodb' ? '/mongodb' : ''}'

// Any of these items and types may be used in any way. Enjoy!

// - shadowplay1`

		return message
	} else {
		const message = 
`// This file contains all the managers and classes Economy has (e.g. EconomyItems)
// This file was generated automatically and not recommended to edit it yourself.
				
// Any of these items can be imported using:
// const { something } = require('discord-economy-super${type == 'mongodb' ? '/mongodb' : ''}')
		
// or in TypeScript (all the economy types and interfaces available) 
// import { something } = from 'discord-economy-super${type == 'mongodb' ? '/mongodb' : ''}'
		
// Any of these items and types may be used in any way. Enjoy!

// - shadowplay1`

		return message
	}
}

const directories: IEconomyFiles = {} as any

for (const source of sources) {
	let jsText = ''
	let tsText = ''
	
	directories[source] = {} as any

	if (source == 'src') {
		for (const type of types) {
			const sourcePath = type == 'json' ? './src' : './mongodb/src'

			for (const baseClassesFolder in baseDirectories.classes) {
				const classesFolder: keyof IClassesFolder = baseClassesFolder as any

				directories[source][type] = {} as any

				directories[source][type].classes = {
					...baseDirectories.classes
				}

				if (classesFolder == 'root') {
						const rootFiles = getFiles(sourcePath + '/classes')
						directories[source][type].classes.root = rootFiles

						for (const rootFile of rootFiles) {
							if (!jsText.includes(rootFile.replace('.js', '')))
								jsText += `  ${createJSDeclaration(rootFile, sourcePath + '/classes')},\n`
						}
				} else {
					const classesFiles = getFiles(sourcePath + `/classes/${classesFolder}`)

					directories[source][type].classes[classesFolder]
						.push(...classesFiles)

					for (const classesFile of classesFiles) {
						if (!jsText.includes(classesFile.replace('.js', '')))
							jsText += `  ${createJSDeclaration(classesFile, sourcePath + `/classes/${classesFolder}`)},\n`
					}
				}
			}

			const managersFiles = getFiles(sourcePath + '/managers')
			directories[source][type].managers = managersFiles

			for (const managersFile of managersFiles) {
				if (!jsText.includes(managersFile.replace('.js', '')))
					jsText += `  ${createJSDeclaration(managersFile, sourcePath + `/managers`)},\n`
			}

			if (type == 'mongodb') {
				const cachedFiles = getFiles(sourcePath + '/cached')
				directories[source][type].cached = cachedFiles

				for (const cachedFile of cachedFiles) {
					jsText += `  ${createJSDeclaration(cachedFile, sourcePath + `/managers`)},\n`
				}
			}

		fileTexts[type].js = generateUserMessage(type, source) + '\n\n' + `module.exports = {\n${jsText}}`
		writeFileSync(`./scripts/test/test-${type}.js`, fileTexts[type].js)
		}
	}

	if (source == 'typings') {
		for (const type of types) {
			const sourcePath = type == 'json' ? './typings' : './mongodb/typings'

			for (const baseClassesFolder in baseDirectories.classes) {
				const classesFolder: keyof IClassesFolder = baseClassesFolder as any

				directories[source][type] = {} as any

				directories[source][type].classes = {
					...baseDirectories.classes
				}

				if (classesFolder == 'root') {
						const rootFiles = getFiles(sourcePath + '/classes')
						directories[source][type].classes.root = rootFiles

						for (const rootFile of rootFiles) {
							if (!tsText.includes(rootFile.replace('.d.ts', '')))
								tsText += `  ${createTSDeclaration(rootFile, sourcePath + '/classes')}\n`
						}
				} else {
					const classesFiles = getFiles(sourcePath + `/classes/${classesFolder}`)

					directories[source][type].classes[classesFolder]
						.push(...classesFiles)

					for (const classesFile of classesFiles) {
						if (!tsText.includes(classesFile.replace('.d.ts', '')))
							tsText += `  ${createTSDeclaration(classesFile, sourcePath + `/classes/${classesFolder}`)}\n`
					}
				}
			}

			const managersFiles = getFiles(sourcePath + '/managers')
			directories[source][type].managers = managersFiles

			for (const managersFile of managersFiles) {
				if (!tsText.includes(managersFile.replace('.d.ts', '')))
					tsText += `  ${createTSDeclaration(managersFile, sourcePath + `/managers`)}\n`
			}

			const interfacesFiles = getFiles(sourcePath + '/interfaces')
			directories[source][type].interfaces = interfacesFiles

			for (const interfacesFile of interfacesFiles) {
				if (!tsText.includes(interfacesFile.replace('.d.ts', '')))
					tsText += `  ${createTSDeclaration(interfacesFile, sourcePath + `/interfaces`, {
						multipleImports: defineMultipleImports(interfacesFile)
					})}\n`
			}

			if (type == 'mongodb') {
				const cachedFiles = getFiles(sourcePath + '/cached')
				directories[source][type].cached = cachedFiles

				for (const cachedFile of cachedFiles) {
					tsText += `  ${createTSDeclaration(cachedFile, sourcePath + `/managers`, {
						multipleImports: defineMultipleImports(cachedFile)
					})}\n`
				}
			}

		fileTexts[type].ts = generateUserMessage(type, source) + '\n\n' + tsText
		writeFileSync(`./scripts/test/test-${type}.d.ts`, fileTexts[type].ts)
			}
		}
	}


console.log('Done!')

interface IEconomyFiles {
	src: {
		json: ISourceFolder<false, false>
		mongodb: ISourceFolder<true, false>
	}
	typings: {
		json: ISourceFolder<false, true>
		mongodb: ISourceFolder<true, true>
	}
}

interface IClassesFolder {
	guild: string[],
	user: string[],
	util: string[],
	root: string[]
}

interface IBaseSourceFolder {
	classes: IClassesFolder
	managers: string[]
}

type IDatabaseDefinedFolder<IsMongoDB extends boolean> = If<
	IsMongoDB,
	IBaseSourceFolder & {
		cached: string[]
	},
	IBaseSourceFolder
>

type ISourceFolder<
	IsMongoDB extends boolean,
	IsTypings extends boolean
> = If<
	IsTypings,
	IDatabaseDefinedFolder<IsMongoDB> & {
		interfaces: string[]
	},
	IDatabaseDefinedFolder<IsMongoDB>
>



// typings examples/tests for `ISourceFolder<IsMongoDB, IsTypings>`

const typingsMongoFolder: ISourceFolder<true, true> = {
	cached: ['asdasd', 'asdasd'],
	classes: {
		guild: ['asdasdasd', 'asdasdasd'],
		user: ['asdsadasd', 'asdasd'],
		util: ['sdffsdf', 'sdfsdf'],
		root: ['asdasdasd', 'adasdasd', 'asdasd']
	},
	managers: ['asdasdasd', 'asdasdasd'],
	interfaces: ['asdasdasd', 'dasasdads']
}

const mongoFolder: ISourceFolder<true, false> = {
	cached: ['asdasd', 'asdasd'],
	classes: {
		guild: ['asdasdasd', 'asdasdasd'],
		user: ['asdsadasd', 'asdasd'],
		util: ['sdffsdf', 'sdfsdf'],
		root: ['asdasdasd', 'adasdasd', 'asdasd']
	},
	managers: ['asdasdasd', 'asdasdasd']
}

const jsonFolder: ISourceFolder<false, false> = {
	classes: {
		guild: ['asdasdasd', 'asdasdasd'],
		user: ['asdsadasd', 'asdasd'],
		util: ['sdffsdf', 'sdfsdf'],
		root: ['asdasdasd', 'adasdasd', 'asdasd']
	},
	managers: ['asdasdasd', 'asdasdasd']
}

const typingsJSONFolder: ISourceFolder<false, true> = {
	classes: {
		guild: ['asdasdasd', 'asdasdasd'],
		user: ['asdsadasd', 'asdasd'],
		util: ['sdffsdf', 'sdfsdf'],
		root: ['asdasdasd', 'adasdasd', 'asdasd']
	},
	managers: ['asdasdasd', 'asdasdasd'],
	interfaces: ['asdasdasd', 'dasasdads']
}



// legacy code

	// fileTexts[source] = {
	// 	json: '',
	// 	mongodb: ''
	// }

	// for (const type of types) {
	// 	directories[source][type] = type == 'json' ? {
	// 		...baseDirectories
	// 	} : {
	// 		cached: [],
	// 		...baseDirectories
	// 	}

	// 	if (type == 'json') {
	// 		for (const dir in directories[source].json.classes) {
	// 			if (dir !== 'root') {
	// 				const classesFolder = readdirSync(`./src/classes/${dir}`).filter(file => !file.startsWith('.'))
	// 				directories[source].json.classes[dir] = classesFolder
	// 			}
	// 		}

	// 		for (const dir in directories[source].json) {
	// 			if (dir !== 'classes') {
	// 				directories[source].json[dir] = readdirSync(`./src/${dir}`).filter(file => !file.startsWith('.'))
	// 			}
	// 		}

	// 		directories[source].json.classes.root = readdirSync('./src/classes').filter(d => d.includes('.'))
	// 	}

	// 	if (type == 'mongodb') {
	// 		for (const dir in directories[source].mongodb.classes) {
	// 			if (dir !== 'root') {
	// 				const classesFolder = readdirSync(`./mongodb/src/classes/${dir}`).filter(file => !file.startsWith('.'))
	// 				directories[source].mongodb.classes[dir] = classesFolder
	// 			}
	// 		}

	// 		for (const dir in directories[source].mongodb) {
	// 			if (dir !== 'classes') {
	// 				directories[source].mongodb[dir] = readdirSync(`./mongodb/src/${dir}`).filter(file => !file.startsWith('.'))
	// 			}
	// 		}

	// 		directories[source].mongodb.classes.root = readdirSync('./mongodb/src/classes').filter(d => d.includes('.'))
	// 	}
	// }

	// const getFiles = (path: string, options?: { declarations?: boolean }): string[] => {
	// 	const files = readdirSync(path)
	// 		.filter(fileName => fileName.includes('.'))
	
	// 	return options?.declarations ?
	// 		files.map(fileName => fileName.replace('.js', '.d.ts')) :
	// 		files
	// }



	// other code

// const toSync = <T>(promise: Promise<T>): T => {
//   let result: T = null as any;
//   let error: any;
//   let isCompleted = false;

//   promise
//     .then((res: T) => {
//       result = res;
//       isCompleted = true;
//     })
//     .catch((err: any) => {
//       error = err;
//       isCompleted = true;
//     });

//   const startTime = Date.now();
//   const timeout = 5000; // 5 seconds timeout

//   while (!isCompleted) {
//     if (Date.now() - startTime > timeout) {
//       throw new Error("Promise took too long to complete or reject");
//     }
//   }

//   if (error) {
//     throw error;
//   }

//   return result;
// };

// const bool = (boolean: boolean = true) =>
//   new Promise<boolean>((resolve) => {
//     setTimeout(() => {
//       resolve(boolean);
//     }, 3000);
//   });

// const boolean = toSync(bool());
// console.log(boolean);
 